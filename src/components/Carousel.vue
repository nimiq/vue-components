<template>
    <div class="carousel">
        <div v-for="entry in entries" :ref="entry"
            :class="{ selected: effectiveSelectedEntry === entry }"
            @click="effectiveSelectedEntry = disabled ? effectiveSelectedEntry : entry"
            @focusin="effectiveSelectedEntry = disabled ? effectiveSelectedEntry : entry">
            <slot :name="entry"></slot>
        </div>
    </div>
</template>

<script lang="ts">
import { Component, Prop, Watch, Vue } from 'vue-property-decorator';
import SmallPage from './SmallPage.vue';

class Tweenable {
    public constructor(
        public targetValue: number = 0,
        public startValue: number = targetValue,
        public tweenTime: number = 0,
        public startTime: number = Date.now(),
        public easing: (progress: number) => number = Tweenable.Easing.EASE_IN_OUT_CUBIC,
    ) {}

    public get currentValue(): number {
        const easedProgress = this.easing(this.progress);
        return this.startValue + (this.targetValue - this.startValue) * easedProgress;
    }

    public get progress(): number {
        if (this.tweenTime === 0) return 1;
        return Math.min(1, (Date.now() - this.startTime) / this.tweenTime);
    }

    public get finished(): boolean {
        return this.progress === 1;
    }

    public tweenTo(targetValue, tweenTime = this.tweenTime) {
        if (targetValue === this.targetValue) return;
        this.startValue = this.currentValue;
        this.targetValue = targetValue;
        this.startTime = Date.now();
        this.tweenTime = tweenTime;
    }
}
namespace Tweenable { // tslint:disable-line no-namespace
    // see https://gist.github.com/gre/1650294 for more easing functions
    export let Easing = { // tslint:disable-line variable-name
        LINEAR: (t: number) => t,
        EASE_IN_OUT_CUBIC: (t: number) => t < .5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1,
    };
}

@Component({components: {SmallPage}})
export default class Carousel extends Vue {
    @Prop({
        type: Array,
        default: [],
        validator: (entries: any) => Array.isArray(entries)
            && entries.length > 0
            && !entries.some((entry) => typeof entry !== 'string'),
    })
    public entries!: string[];

    @Prop(String)
    public selectedEntry?: string;

    @Prop({
        type: Number,
        default: 16,
    })
    public entryMargin!: number;

    @Prop({
        type: Number,
        default: 1000,
    })
    public animationDuration!: number; // in ms

    @Prop({
        type: Boolean,
        default: false,
    })
    public hideBackgroundEntries!: boolean;

    @Prop({
        type: Boolean,
        default: false,
    })
    public disabled!: boolean;

    public $refs: { [ref: string]: HTMLElement[] }; // these are arrays because of v-for

    private effectiveSelectedEntry: string = '';
    private radius: Tweenable = new Tweenable();
    private rotations: Map<string, Tweenable> = new Map(); // map entry -> rotation
    private requestAnimationFrameId: number | null = null;

    private get _hasDummyPosition(): boolean {
        // add dummy to avoid that second entry is hidden exactly behind selected item on opposite side of circle.
        return this.entries.length <= 2;
    }

    private get _totalPositionCount(): number {
        return this.entries.length + (this._hasDummyPosition ? 1 : 0);
    }

    private mounted() {
        this._onKeydown = this._onKeydown.bind(this);
        document.addEventListener('keydown', this._onKeydown);
        this._updateDimensions(false);
        this._updateRotations(false);
    }

    private destroyed() {
        document.removeEventListener('keydown', this._onKeydown);
        if (this.requestAnimationFrameId === null) return;
        cancelAnimationFrame(this.requestAnimationFrameId);
    }

    @Watch('entries', { immediate: true })
    @Watch('entries.length', { immediate: true })
    @Watch('selectedEntry', { immediate: true })
    private _onExternalSelection() {
        const isNewSelectionValid = this.entries.indexOf(this.selectedEntry) !== -1;
        const isOldSelectionValid = this.entries.indexOf(this.effectiveSelectedEntry) !== -1;
        if (isNewSelectionValid) {
            this.effectiveSelectedEntry = this.selectedEntry;
        } else if (!isOldSelectionValid) {
            this.effectiveSelectedEntry = this.entries[0];
        } // else keep the old selection
    }

    @Watch('entries')
    @Watch('entries.length')
    @Watch('entryMargin')
    private async _updateDimensions(newWatcherValueOrTween, previousWatcherValue?) {
        const tween = typeof newWatcherValueOrTween === 'boolean' && typeof previousWatcherValue === 'undefined'
            ? newWatcherValueOrTween // specified whether to tween
            : true; // did not specify whether to tween or method was called as a watcher (default to true)
        await Vue.nextTick(); // let Vue render new entries
        let largestHeight = 0;
        let largestMinDistance = 0;
        for (let i = 0; i < this.entries.length; ++i) {
            const [ el1 ] = this.$refs[this.entries[i]];
            const [ el2 ] = this.$refs[this.entries[(i + 1) % this.entries.length]];
            largestHeight = Math.max(largestHeight, el1.offsetHeight);
            const minDistance = el1.offsetWidth / 2 + el2.offsetWidth / 2 + this.entryMargin;
            largestMinDistance = Math.max(largestMinDistance, minDistance);
        }
        // Choose radius big enough such that two items can be rendered side by side without overlapping.
        // Calculate on a right triangle formed by radius, half distance and perpendicular from center point
        // to distance line.
        const centerAngle = 2 * Math.PI / this._totalPositionCount / 2; // angle at circle center point
        const radius = (largestMinDistance / 2) / Math.sin(centerAngle);
        this.radius.tweenTo(radius, tween ? this.animationDuration : 0);
        (this.$el as HTMLElement).style.minHeight = `${largestHeight}px`;
        this._rerender();
    }

    @Watch('entries')
    @Watch('effectiveSelectedEntry')
    @Watch('disabled')
    private _updateRotations(newWatcherValueOrTween, previousWatcherValue?) {
        const tween = typeof newWatcherValueOrTween === 'boolean' && typeof previousWatcherValue === 'undefined'
            ? newWatcherValueOrTween // specified whether to tween
            : true; // did not specify whether to tween or method was called as a watcher (default to true)
        // clean up removed entries
        for (const entry of this.rotations.keys()) {
            if (this.entries.indexOf(entry) !== -1) continue;
            this.rotations.delete(entry);
        }
        // update rotations
        for (const entry of this.entries) {
            const rotation = this.rotations.get(entry) || new Tweenable();
            const tweenTime = tween ? this.animationDuration : 0;
            rotation.tweenTo(this._calculateTargetRotation(entry, rotation.currentValue), tweenTime);
            this.rotations.set(entry, rotation);
        }
        this._rerender();
    }

    private _calculateTargetRotation(entry, currentRotation): number { // rotation in radians
        if (this.disabled && entry !== this.effectiveSelectedEntry) {
            // hide not selected entries at other end of circle
            return currentRotation + this._calculateRotationInClosestDirection(currentRotation, Math.PI);
        }
        const stepSize = 2 * Math.PI / this._totalPositionCount;
        const entryIndex = this.entries.indexOf(entry);
        const selectedEntryIndex = this.entries.indexOf(this.effectiveSelectedEntry);
        let offset = entryIndex - selectedEntryIndex;
        if (this._hasDummyPosition && offset > this._totalPositionCount / 2) {
            // skip dummy position
            offset += 1;
        }
        return currentRotation + this._calculateRotationInClosestDirection(currentRotation, offset * stepSize);
    }

    @Watch('hideBackgroundEntries')
    private _rerender() {
        if (this.requestAnimationFrameId !== null) return;
        this.requestAnimationFrameId = requestAnimationFrame(() => {
            const zCoordinatesForEntries: Array<[string, number]> = [];
            let finished = this.radius.finished;
            for (const [entry, rotation] of this.rotations) {
                const currentRotation = rotation.currentValue;
                const currentRadius = this.radius.currentValue;
                const x = Math.sin(currentRotation) * currentRadius;
                const z = Math.cos(currentRotation) * currentRadius - currentRadius;
                const [ el ] = this.$refs[entry];
                el.style.transform = `translate3d(calc(${x}px - 50%),-50%,${z}px)`;
                el.style.display = this._shouldHide(entry) ? 'none' : '';
                zCoordinatesForEntries.push([entry, z]);
                finished = finished && rotation.finished;
            }

            zCoordinatesForEntries.sort(([, z1], [, z2]) => z1 - z2);
            for (let i = 0; i < zCoordinatesForEntries.length; ++i) {
                const [ el ] = this.$refs[zCoordinatesForEntries[i][0]];
                el.style.zIndex = `${i}`;
            }

            this.requestAnimationFrameId = null;
            if (!finished) this._rerender();
        });
    }

    private _calculateRotationInClosestDirection(fromAngle, toAngle): number {
        // angle offset modulo full rotations
        const rotation = (toAngle - fromAngle) % (2 * Math.PI);
        // determine rotation in opposite direction (subtracting or adding a full circle depending on direction (sign))
        const rotationOppositeDirection = rotation - Math.sign(rotation) * 2 * Math.PI;
        if (Math.abs(Math.abs(rotation) - Math.abs(rotationOppositeDirection)) < 1e-10) {
            // in case of ambiguity chose a default direction
            return Math.min(rotation, rotationOppositeDirection);
        } else if (Math.abs(rotation) < Math.abs(rotationOppositeDirection)) {
            return rotation;
        } else {
            return rotationOppositeDirection;
        }
    }

    private _shouldHide(entry): boolean {
        const rotation = this.rotations.get(entry);
        if (!rotation) return false;
        const absoluteRotation = Math.abs(this._calculateRotationInClosestDirection(0, rotation.currentValue));
        if (this.disabled) {
            // Hide disabled elements once they reached the opposite end of the circle, also to avoid that they are
            // still reachable via tab. While they're animating to get there, display them even when they're in the
            // back part of the circle.
            return Math.abs(absoluteRotation - Math.PI) < 1e-10;
        } else if (this.hideBackgroundEntries) {
            // Hide entries in the back part of the circle as these will not be visible behind the front entries
            const stepSize = 2 * Math.PI / this._totalPositionCount;
            const threshold = Math.PI / 2 + stepSize / (this._totalPositionCount - 1); // just a heuristic but works ok
            return absoluteRotation > threshold;
        }
    }

    private _onKeydown(event) {
        const target = event.path[0] as HTMLElement;
        if (this.disabled
            || target.tagName === 'INPUT'
            || target.tagName === 'TEXTAREA'
            || this.rotations.values().next().value.progress < .5 // block if previous change not animated far enough
        ) return;
        const currentIndex = this.entries.indexOf(this.effectiveSelectedEntry);
        let newIndex;
        if (event.which === 37) {
            // left arrow key
            newIndex = (currentIndex - 1 + this.entries.length) % this.entries.length;
        } else if (event.which === 39) {
            // right arrow key
            newIndex = (currentIndex + 1) % this.entries.length;
        } else {
            return;
        }
        this.effectiveSelectedEntry = this.entries[newIndex];
    }
}
</script>

<style scoped>
    .carousel {
        position: relative;
        padding: 4rem;
        box-sizing: content-box;
        perspective: 1500px;
        /* perspective-origin: center 150%; */ /* useful for debugging */
    }

    .carousel > * {
        position: absolute;
        left: 50%;
        top: 50%;
    }

    .carousel > :not(.selected) >>> * {
        pointer-events: none !important;
    }
</style>

